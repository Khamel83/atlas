#!/usr/bin/env python3
"""
Atlas Bulk URL Sender (SMTP Version)
Sends batches of URLs to Gmail for Atlas ingestion using SMTP

Usage:
    python atlas_bulk_sender.py backlog.txt
    python atlas_bulk_sender.py backlog.txt --batch-size 250 --daily-limit 2000
    python atlas_bulk_sender.py backlog.txt --dry-run  # Test without sending
"""

import os
import sys
import json
import time
import smtplib
import argparse
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Dict
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class BulkSender:
    def __init__(self, email_address: str, app_password: str, smtp_host: str = 'smtp.gmail.com', smtp_port: int = 587):
        """Initialize the bulk sender with SMTP credentials."""
        self.email_address = email_address
        self.app_password = app_password
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.progress_file = Path('bulk_sender_progress.json')
        self.progress = self.load_progress()

    def load_progress(self) -> Dict:
        """Load progress from file to enable resume."""
        if self.progress_file.exists():
            with open(self.progress_file, 'r') as f:
                return json.load(f)
        return {
            'total_urls': 0,
            'urls_sent': 0,
            'batches_sent': 0,
            'last_sent_date': None,
            'emails_sent_today': 0,
            'failed_batches': [],
            'completed': False
        }

    def save_progress(self):
        """Save progress to file."""
        with open(self.progress_file, 'w') as f:
            json.dump(self.progress, f, indent=2)

    def test_smtp_connection(self) -> bool:
        """Test SMTP connection and authentication."""
        try:
            print(f"üîå Testing SMTP connection to {self.smtp_host}:{self.smtp_port}...")

            # Connect to SMTP server
            server = smtplib.SMTP(self.smtp_host, self.smtp_port)
            server.set_debuglevel(0)  # Set to 1 for verbose debugging
            server.ehlo()
            server.starttls()
            server.ehlo()

            # Authenticate
            server.login(self.email_address, self.app_password)

            print("‚úÖ SMTP connection successful")
            server.quit()
            return True

        except smtplib.SMTPAuthenticationError as e:
            print(f"‚ùå SMTP Authentication failed: {e}")
            print("\nTo fix this:")
            print("1. Verify your app password in .env (GMAIL_APP_PASSWORD)")
            print("2. Ensure you're using an app password, not your regular password")
            print("3. Generate new app password at: https://myaccount.google.com/apppasswords")
            return False

        except Exception as e:
            print(f"‚ùå SMTP connection failed: {e}")
            return False

    def read_urls(self, file_path: str) -> List[str]:
        """Read URLs from file, one per line."""
        print(f"üìñ Reading URLs from: {file_path}")

        if not Path(file_path).exists():
            print(f"‚ùå ERROR: File not found: {file_path}")
            sys.exit(1)

        with open(file_path, 'r') as f:
            urls = [line.strip() for line in f if line.strip() and line.strip().startswith('http')]

        print(f"‚úÖ Read {len(urls)} URLs from file")
        return urls

    def chunk_urls(self, urls: List[str], batch_size: int) -> List[List[str]]:
        """Split URLs into batches."""
        batches = [urls[i:i + batch_size] for i in range(0, len(urls), batch_size)]
        print(f"üì¶ Split into {len(batches)} batches of {batch_size} URLs each")
        return batches

    def create_email_message(self, urls: List[str], batch_num: int, total_batches: int) -> MIMEMultipart:
        """Create email message with URLs."""
        subject = f"Atlas Bulk Import - Batch {batch_num} of {total_batches}"

        body = f"""Atlas Bulk Import - Batch {batch_num} of {total_batches}

The following URLs are queued for processing:

{chr(10).join(urls)}

---
Total URLs in this batch: {len(urls)}
Auto-generated by atlas_bulk_sender.py
Sent: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""

        # Create multipart message
        message = MIMEMultipart()
        message['From'] = self.email_address
        message['To'] = self.email_address
        message['Subject'] = subject

        # Add body
        message.attach(MIMEText(body, 'plain'))

        return message

    def send_email_smtp(self, message: MIMEMultipart) -> bool:
        """Send email via SMTP."""
        try:
            # Connect to SMTP server
            server = smtplib.SMTP(self.smtp_host, self.smtp_port)
            server.set_debuglevel(0)
            server.ehlo()
            server.starttls()
            server.ehlo()

            # Authenticate
            server.login(self.email_address, self.app_password)

            # Send the message
            server.send_message(message)

            # Close connection
            server.quit()

            return True

        except smtplib.SMTPAuthenticationError as e:
            print(f"‚ùå SMTP authentication error: {e}")
            return False
        except smtplib.SMTPException as e:
            print(f"‚ùå SMTP error sending email: {e}")
            return False
        except Exception as e:
            print(f"‚ùå Error sending email: {e}")
            return False

    def check_daily_limit(self, daily_limit: int) -> bool:
        """Check if we've hit the daily sending limit."""
        today = datetime.now().strftime('%Y-%m-%d')

        # Reset counter if it's a new day
        if self.progress['last_sent_date'] != today:
            self.progress['last_sent_date'] = today
            self.progress['emails_sent_today'] = 0
            self.save_progress()

        # Check if we've hit the limit
        if self.progress['emails_sent_today'] >= daily_limit:
            return False

        return True

    def wait_until_tomorrow(self):
        """Wait until midnight to continue sending."""
        now = datetime.now()
        tomorrow = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
        wait_seconds = (tomorrow - now).total_seconds()

        print(f"\n‚è∞ Daily limit reached. Waiting until {tomorrow.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"   (Sleeping for {wait_seconds/3600:.1f} hours)")

        time.sleep(wait_seconds)

    def send_batches(self, batches: List[List[str]], daily_limit: int = 2000, delay: float = 0.5, dry_run: bool = False):
        """Send all batches with rate limiting."""
        total_batches = len(batches)
        start_batch = self.progress['batches_sent']

        print(f"\nüöÄ Starting bulk send:")
        print(f"   Total batches: {total_batches}")
        print(f"   Already sent: {start_batch}")
        print(f"   Remaining: {total_batches - start_batch}")
        print(f"   Daily limit: {daily_limit} emails")
        print(f"   Delay between emails: {delay}s")

        if dry_run:
            print("\n‚ö†Ô∏è  DRY RUN MODE - No emails will be sent")

        for i in range(start_batch, total_batches):
            batch_num = i + 1
            urls = batches[i]

            # Check daily limit
            if not self.check_daily_limit(daily_limit):
                self.save_progress()
                self.wait_until_tomorrow()

            # Create and send email
            print(f"\nüìß Batch {batch_num}/{total_batches} ({len(urls)} URLs)")

            if dry_run:
                print(f"   [DRY RUN] Would send email with {len(urls)} URLs")
            else:
                message = self.create_email_message(urls, batch_num, total_batches)

                if self.send_email_smtp(message):
                    print(f"   ‚úÖ Sent successfully")
                    self.progress['batches_sent'] += 1
                    self.progress['urls_sent'] += len(urls)
                    self.progress['emails_sent_today'] += 1
                    self.save_progress()
                else:
                    print(f"   ‚ùå Failed to send")
                    self.progress['failed_batches'].append(batch_num)
                    self.save_progress()

                # Rate limiting delay
                if i < total_batches - 1:
                    time.sleep(delay)

        self.progress['completed'] = True
        self.save_progress()

        print(f"\n‚úÖ Bulk send complete!")
        print(f"   Total URLs sent: {self.progress['urls_sent']}")
        print(f"   Total emails sent: {self.progress['batches_sent']}")
        print(f"   Failed batches: {len(self.progress['failed_batches'])}")


def load_env_vars():
    """Load environment variables from .env file."""
    env_file = Path('.env')
    if not env_file.exists():
        return {}

    env_vars = {}
    with open(env_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                env_vars[key.strip()] = value.strip()

    return env_vars


def main():
    parser = argparse.ArgumentParser(
        description='Send bulk URLs to Gmail for Atlas ingestion (SMTP version)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python atlas_bulk_sender.py backlog.txt
  python atlas_bulk_sender.py backlog.txt --batch-size 250
  python atlas_bulk_sender.py backlog.txt --daily-limit 2000
  python atlas_bulk_sender.py backlog.txt --dry-run
  python atlas_bulk_sender.py backlog.txt --reset-progress
        """
    )

    parser.add_argument('input_file', help='File containing URLs (one per line)')
    parser.add_argument('--batch-size', type=int, default=250,
                       help='Number of URLs per email (default: 250)')
    parser.add_argument('--daily-limit', type=int, default=2000,
                       help='Daily email sending limit (default: 2000 for free Gmail)')
    parser.add_argument('--delay', type=float, default=0.5,
                       help='Delay between emails in seconds (default: 0.5)')
    parser.add_argument('--email', type=str, default=None,
                       help='Your Gmail address (default: from .env GMAIL_EMAIL_ADDRESS)')
    parser.add_argument('--app-password', type=str, default=None,
                       help='Gmail app password (default: from .env GMAIL_APP_PASSWORD)')
    parser.add_argument('--smtp-host', type=str, default='smtp.gmail.com',
                       help='SMTP server host (default: smtp.gmail.com)')
    parser.add_argument('--smtp-port', type=int, default=587,
                       help='SMTP server port (default: 587)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Test mode - don\'t actually send emails')
    parser.add_argument('--reset-progress', action='store_true',
                       help='Reset progress and start from beginning')

    args = parser.parse_args()

    # Load from .env if not provided
    env_vars = load_env_vars()

    email_address = args.email or env_vars.get('GMAIL_EMAIL_ADDRESS')
    app_password = args.app_password or env_vars.get('GMAIL_APP_PASSWORD')

    # Validate required parameters
    if not email_address:
        print("‚ùå ERROR: Gmail email address required")
        print("   Provide via --email or set GMAIL_EMAIL_ADDRESS in .env")
        sys.exit(1)

    if not app_password:
        print("‚ùå ERROR: Gmail app password required")
        print("   Provide via --app-password or set GMAIL_APP_PASSWORD in .env")
        print("\nTo generate an app password:")
        print("1. Go to https://myaccount.google.com/apppasswords")
        print("2. Sign in with your Gmail account")
        print("3. Select app: Mail")
        print("4. Select device: Other -> 'Atlas'")
        print("5. Click Generate")
        print("6. Copy the 16-character password to your .env file")
        sys.exit(1)

    # Expand input file path
    input_file = os.path.expanduser(args.input_file)

    print(f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë             Atlas Bulk URL Sender (SMTP)                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Configuration:
  Input file:     {input_file}
  Batch size:     {args.batch_size} URLs per email
  Daily limit:    {args.daily_limit} emails/day
  Email address:  {email_address}
  SMTP server:    {args.smtp_host}:{args.smtp_port}
  Dry run:        {args.dry_run}
""")

    # Initialize sender
    sender = BulkSender(email_address, app_password, args.smtp_host, args.smtp_port)

    # Reset progress if requested
    if args.reset_progress:
        print("üîÑ Resetting progress...")
        sender.progress_file.unlink(missing_ok=True)
        sender.progress = sender.load_progress()

    # Test SMTP connection
    if not args.dry_run:
        if not sender.test_smtp_connection():
            print("\n‚ùå SMTP connection test failed. Please check your credentials.")
            sys.exit(1)

    # Read URLs
    urls = sender.read_urls(input_file)

    if not urls:
        print("‚ùå No URLs found in file")
        sys.exit(1)

    # Update total URLs in progress
    sender.progress['total_urls'] = len(urls)
    sender.save_progress()

    # Chunk URLs into batches
    batches = sender.chunk_urls(urls, args.batch_size)

    # Send batches
    sender.send_batches(batches, args.daily_limit, args.delay, args.dry_run)

    print("\n" + "="*60)
    print("DONE! Your backlog has been sent to Gmail for Atlas processing.")
    print("\nIMPORTANT: To ensure Atlas processes these emails:")
    print("1. Set up a Gmail filter to label these emails with 'Atlas'")
    print("2. Or manually apply the 'Atlas' label to the received emails")
    print("3. Atlas will automatically process emails with the 'Atlas' label")
    print("="*60)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Interrupted by user. Progress has been saved.")
        print("Run the script again to resume from where you left off.")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå ERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
